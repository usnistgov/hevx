#version 460 core
#extension GL_NV_ray_tracing : require

layout(push_constant) uniform PushConstants {
  vec4 padding0;
  float iTime;
  float iTimeDelta;
  float iFrameRate;
  float iFrame;
  vec3 padding1;
  float padding2;
  vec4 EyePosition;
  mat4 ModelMatrix;
  mat4 ModelViewMatrix;
  mat3 NormalMatrix;
};

struct Sphere {
  float aabbMinX;
  float aabbMinY;
  float aabbMinZ;
  float aabbMaxX;
  float aabbMaxY;
  float aabbMaxZ;
};

layout(std430, set = 1, binding = 2) readonly buffer SphereBuffer {
  Sphere spheres[];
};

hitAttributeNV vec3 normalVector;

void main() {
  const vec3 origin = gl_WorldRayOriginNV;
  const vec3 direction = normalize(gl_WorldRayDirectionNV);

  Sphere sphere = spheres[gl_PrimitiveID];
  const vec3 aabbMin = vec3(sphere.aabbMinX, sphere.aabbMinY, sphere.aabbMinZ);
  const vec3 aabbMax = vec3(sphere.aabbMaxX, sphere.aabbMaxY, sphere.aabbMaxZ);

  const vec3 center =
  (ModelMatrix * vec4((aabbMax + aabbMin) / vec3(2.f), 1.f)).xyz;
  const float radius = (aabbMax.x - aabbMin.x) / 2.f;

  const vec3 oc = origin - center.xyz;
  const float a = dot(direction, direction);
  const float b = dot(oc, direction);
  const float c = dot(oc, oc) - (radius * radius);
  const float d = b * b - a * c;

  if (d > 0.f) {
    const float sd = sqrt(d);
    const float t1 = (-b - sd) / a;
    const float t2 = (-b + sd) / a;

    if (gl_RayTminNV < t1 && t1 < gl_RayTmaxNV) {
      const vec3 hitValue = origin + t1 * direction;
      normalVector = (hitValue - center.xyz) / radius;
      normalVector.y *= -1.f; // Deal with the wacky viewport stuff
      reportIntersectionNV(t1, 0);
    } else if (gl_RayTminNV < t2 && t2 < gl_RayTmaxNV) {
      const vec3 hitValue = origin + t2 * direction;
      normalVector = (hitValue - center.xyz) / radius;
      normalVector.y *= -1.f; // Deal with the wacky viewport stuff
      reportIntersectionNV(t2, 0);
    }
  }
}

